use std::collections::BTreeMap;
use std::fs;
use std::path::{Path, PathBuf};
use anyhow::{Context, Result};
use configparser::ini::Ini;

use crate::icon_catalog::IconFormat;
use crate::icon_theme::DirectoryType;

pub struct ThemePackGenerator {
    theme_name: String,
    theme_comment: String,
    output_dir: PathBuf,
    icon_replacements: BTreeMap<String, PathBuf>,
    size_specific_replacements: BTreeMap<String, BTreeMap<u32, PathBuf>>,
    icon_links: BTreeMap<String, bool>,
    size_specific_links: BTreeMap<String, BTreeMap<u32, bool>>,
    icon_categories: BTreeMap<String, String>, // icon_name -> category
    fallback_themes: Vec<String>,
}

impl ThemePackGenerator {
    pub fn new(theme_name: String, output_dir: PathBuf) -> Self {
        Self {
            theme_name,
            theme_comment: "Icon theme generated by icon-packer".to_string(),
            output_dir,
            icon_replacements: BTreeMap::new(),
            size_specific_replacements: BTreeMap::new(),
            icon_links: BTreeMap::new(),
            size_specific_links: BTreeMap::new(),
            icon_categories: BTreeMap::new(),
            fallback_themes: vec!["hicolor".to_string()],
        }
    }
    
    pub fn set_fallback_themes(&mut self, themes: Vec<String>) {
        self.fallback_themes = themes;
    }
    
    pub fn set_theme_comment(&mut self, comment: String) {
        self.theme_comment = comment;
    }
    
    pub fn add_size_replacement(&mut self, icon_name: String, size: u32, source_path: PathBuf) {
        self.size_specific_replacements
            .entry(icon_name)
            .or_insert_with(BTreeMap::new)
            .insert(size, source_path);
    }

    pub fn add_replacement(&mut self, icon_name: String, source_path: PathBuf) {
        self.icon_replacements.insert(icon_name, source_path);
    }
    
    pub fn set_replacement_link(&mut self, icon_name: String, is_link: bool) {
        self.icon_links.insert(icon_name, is_link);
    }
    
    pub fn set_size_replacement_link(&mut self, icon_name: String, size: u32, is_link: bool) {
        self.size_specific_links
            .entry(icon_name)
            .or_insert_with(BTreeMap::new)
            .insert(size, is_link);
    }
    
    pub fn set_icon_category(&mut self, icon_name: String, category: String) {
        self.icon_categories.insert(icon_name, category);
    }

    pub fn generate(&self) -> Result<()> {
        fs::create_dir_all(&self.output_dir)
            .with_context(|| format!("Failed to create output directory: {}", self.output_dir.display()))?;

        // Get set of all icon names that should exist
        let mut active_icons = std::collections::HashSet::new();
        for icon_name in self.icon_replacements.keys() {
            active_icons.insert(icon_name.clone());
        }
        for icon_name in self.size_specific_replacements.keys() {
            active_icons.insert(icon_name.clone());
        }

        // Standard sizes and contexts
        let directories = vec![
            ("16x16", 16, DirectoryType::Fixed),
            ("22x22", 22, DirectoryType::Fixed),
            ("32x32", 32, DirectoryType::Fixed),
            ("48x48", 48, DirectoryType::Fixed),
            ("64x64", 64, DirectoryType::Fixed),
            ("128x128", 128, DirectoryType::Fixed),
            ("scalable", 48, DirectoryType::Scaled),
        ];

        // Map category names to context names
        let category_to_context = |cat: &str| -> String {
            match cat {
                "Applications" => "apps".to_string(),
                "Mimetypes" => "mimetypes".to_string(),
                "Actions" => "actions".to_string(),
                "Places" => "places".to_string(),
                "Devices" => "devices".to_string(),
                "Status" => "status".to_string(),
                _ => "apps".to_string(), // Default to apps
            }
        };

        // Track all created directories for index.theme
        let mut dir_defs = Vec::new();
        let mut created_dirs: std::collections::HashSet<(String, u32, String, String)> = std::collections::HashSet::new(); // (dir_path, size, dir_type_str, category)

        // Helper to get category for icon
        let get_category = |icon_name: &str| -> String {
            self.icon_categories.get(icon_name)
                .cloned()
                .unwrap_or_else(|| "Applications".to_string())
        };

        // Helper to create category subdirectory path
        let get_category_dir = |base_dir: &str, category: &str| -> String {
            let context = category_to_context(category);
            format!("{}/{}", base_dir, context)
        };

        // Helper to copy or link file
        let copy_or_link = |source: &PathBuf, dest: &PathBuf, is_link: bool| -> Result<()> {
            // Remove existing file if it exists
            if dest.exists() {
                fs::remove_file(dest)
                    .with_context(|| format!("Failed to remove existing file: {}", dest.display()))?;
            }
            
            if is_link {
                // Create symlink
                #[cfg(unix)]
                {
                    std::os::unix::fs::symlink(source, dest)
                        .with_context(|| format!("Failed to create symlink {} -> {}", dest.display(), source.display()))?;
                }
                #[cfg(windows)]
                {
                    std::os::windows::fs::symlink_file(source, dest)
                        .with_context(|| format!("Failed to create symlink {} -> {}", dest.display(), source.display()))?;
                }
                log::info!("Linked {} -> {}", dest.display(), source.display());
            } else {
                // Copy file
                fs::copy(source, dest)
                    .with_context(|| format!("Failed to copy {} to {}", source.display(), dest.display()))?;
                log::info!("Copied {} -> {}", source.display(), dest.display());
            }
            Ok(())
        };

        // Process size-specific replacements
        for (icon_name, size_map) in &self.size_specific_replacements {
            let category = get_category(icon_name);
            for (size, source_path) in size_map {
                let format = detect_format(source_path)?;
                if let Some((dir_name, _, _)) = directories.iter().find(|(_, dir_size, _)| *dir_size == *size) {
                    let ext = match format {
                        IconFormat::Svg => "svg",
                        IconFormat::Png => "png",
                        IconFormat::Xpm => "xpm",
                        _ => continue,
                    };
                    let category_subdir = get_category_dir(dir_name, &category);
                    let category_path = self.output_dir.join(&category_subdir);
                    fs::create_dir_all(&category_path)
                        .with_context(|| format!("Failed to create directory: {}", category_path.display()))?;
                    
                    let dest = category_path.join(format!("{}.{}", icon_name, ext));
                    let is_link = self.size_specific_links
                        .get(icon_name)
                        .and_then(|m| m.get(size))
                        .copied()
                        .unwrap_or(false);
                    
                    copy_or_link(source_path, &dest, is_link)?;
                    
                    created_dirs.insert((category_subdir.clone(), *size, "Fixed".to_string(), category.clone()));
                }
            }
        }
        
        // Process general replacements (not size-specific)
        for (icon_name, source_path) in &self.icon_replacements {
            // Skip if this icon has size-specific replacements
            if self.size_specific_replacements.contains_key(icon_name) {
                continue;
            }
            
            let category = get_category(icon_name);
            let format = detect_format(source_path)?;
            let is_link = self.icon_links.get(icon_name).copied().unwrap_or(false);
            
            match format {
                IconFormat::Svg => {
                    // Place SVG in scalable/{category}/
                    let category_subdir = get_category_dir("scalable", &category);
                    let category_path = self.output_dir.join(&category_subdir);
                    fs::create_dir_all(&category_path)
                        .with_context(|| format!("Failed to create directory: {}", category_path.display()))?;
                    
                    let dest = category_path.join(format!("{}.svg", icon_name));
                    copy_or_link(source_path, &dest, is_link)?;
                    created_dirs.insert((category_subdir, 48, "Scaled".to_string(), category));
                }
                IconFormat::Png => {
                    // Place PNG in all fixed-size/{category}/ directories
                    for (dir_name, size, _) in &directories {
                        if *dir_name == "scalable" {
                            continue;
                        }
                        let category_subdir = get_category_dir(dir_name, &category);
                        let category_path = self.output_dir.join(&category_subdir);
                        fs::create_dir_all(&category_path)
                            .with_context(|| format!("Failed to create directory: {}", category_path.display()))?;
                        
                        let dest = category_path.join(format!("{}.png", icon_name));
                        copy_or_link(source_path, &dest, is_link)?;
                        created_dirs.insert((category_subdir, *size, "Fixed".to_string(), category.clone()));
                    }
                }
                _ => {
                    log::warn!("Unsupported format for {}: {:?}", icon_name, format);
                }
            }
        }

        // Clean up old icon files that are no longer in replacements
        self.cleanup_old_icons(&active_icons, &created_dirs)?;

        // Build directory definitions from created directories
        for (dir_path, size, dir_type_str, category) in created_dirs {
            let context = category_to_context(&category);
            let dir_type = match dir_type_str.as_str() {
                "Scaled" => DirectoryType::Scaled,
                _ => DirectoryType::Fixed,
            };
            dir_defs.push((dir_path, size, dir_type, context));
        }

        // Generate index.theme
        self.generate_index_theme(&dir_defs)?;

        Ok(())
    }
    
    fn cleanup_old_icons(&self, active_icons: &std::collections::HashSet<String>, _created_dirs: &std::collections::HashSet<(String, u32, String, String)>) -> Result<()> {
        // Get all possible base directories
        let base_dirs = vec!["16x16", "22x22", "32x32", "48x48", "64x64", "128x128", "scalable"];
        let category_subdirs = vec!["apps", "mimetypes", "actions", "places", "devices", "status"];
        
        // Scan all possible directories
        for base_dir in base_dirs {
            let base_path = self.output_dir.join(base_dir);
            if !base_path.exists() {
                continue;
            }
            
            // Check category subdirectories
            for cat_dir in &category_subdirs {
                let cat_path = base_path.join(cat_dir);
                if !cat_path.exists() {
                    continue;
                }
                
                if let Ok(entries) = std::fs::read_dir(&cat_path) {
                    for entry in entries.flatten() {
                        let path = entry.path();
                        if path.is_file() {
                            if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                                if !active_icons.contains(stem) {
                                    // This icon is no longer active, remove it
                                    if let Err(e) = std::fs::remove_file(&path) {
                                        log::warn!("Failed to remove old icon file {}: {}", path.display(), e);
                                    } else {
                                        log::info!("Removed old icon file: {}", path.display());
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Also check flat directories (for backwards compatibility)
            if let Ok(entries) = std::fs::read_dir(&base_path) {
                for entry in entries.flatten() {
                    let path = entry.path();
                    if path.is_file() {
                        if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                            if !active_icons.contains(stem) {
                                // This icon is no longer active, remove it
                                if let Err(e) = std::fs::remove_file(&path) {
                                    log::warn!("Failed to remove old icon file {}: {}", path.display(), e);
                                } else {
                                    log::info!("Removed old icon file: {}", path.display());
                                }
                            }
                        }
                    }
                }
            }
        }
        Ok(())
    }

    fn generate_index_theme(&self, dir_defs: &[(String, u32, DirectoryType, String)]) -> Result<()> {
        let mut ini = Ini::new();
        
        // Icon Theme section
        let directories_list: Vec<String> = dir_defs.iter().map(|(name, _, _, _)| name.clone()).collect();
        // Use theme_name if provided, otherwise use a default
        let theme_display_name = if !self.theme_name.is_empty() {
            self.theme_name.clone()
        } else {
            "Custom Icon Theme".to_string()
        };
        ini.set("Icon Theme", "Name", Some(theme_display_name.clone()));
        ini.set("Icon Theme", "Comment", Some(self.theme_comment.clone()));
        ini.set("Icon Theme", "Directories", Some(directories_list.join(",")));
        // Use configured fallback themes
        let inherits = if self.fallback_themes.is_empty() {
            "hicolor".to_string()
        } else {
            self.fallback_themes.join(",")
        };
        ini.set("Icon Theme", "Inherits", Some(inherits));

        // Directory sections
        for (dir_name, size, dir_type, context) in dir_defs {
            let section = dir_name.as_str();
            ini.set(section, "Size", Some(size.to_string()));
            ini.set(section, "Type", Some(match dir_type {
                DirectoryType::Fixed => "Fixed",
                DirectoryType::Scaled => "Scaled",
                DirectoryType::Threshold => "Threshold",
            }.to_string()));
            ini.set(section, "Context", Some(context.clone()));
            
            if *dir_type == DirectoryType::Scaled {
                ini.set(section, "MinSize", Some("1".to_string()));
                ini.set(section, "MaxSize", Some("256".to_string()));
            }
        }

        let index_path = self.output_dir.join("index.theme");
        ini.write(index_path.to_str().unwrap())
            .map_err(|e| anyhow::anyhow!("Failed to write index.theme: {}", e))?;

        Ok(())
    }
}

fn detect_format(path: &Path) -> Result<IconFormat> {
    let ext = path.extension()
        .and_then(|e| e.to_str())
        .map(|s| s.to_lowercase());
    match ext.as_deref() {
        Some("svg") => Ok(IconFormat::Svg),
        Some("png") => Ok(IconFormat::Png),
        Some("xpm") => Ok(IconFormat::Xpm),
        _ => Ok(IconFormat::Other),
    }
}

